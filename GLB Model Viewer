// 4/8: mobile stable; desktop dragging no longer works. do we need it?

import React, { useEffect, useRef, useState } from "react";
import { addPropertyControls, ControlType } from "framer";

const ThreeJSURL = "https://unpkg.com/three@0.136.0/build/three.min.js";
const GLTFLoaderURL = "https://unpkg.com/three@0.136.0/examples/js/loaders/GLTFLoader.js";
const OrbitControlsURL = "https://unpkg.com/three@0.136.0/examples/js/controls/OrbitControls.js";

// Shared WebGL context management
const MAX_WEBGL_CONTEXTS = 4;
const activeContexts = new Set();

// Global script loading
const scriptCache = new Map();
const loadScript = (url) => {
    if (scriptCache.has(url)) return scriptCache.get(url);
    const promise = new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = url;
        script.async = true;
        script.onload = () => resolve(true);
        script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
        document.head.appendChild(script);
    });
    scriptCache.set(url, promise);
    return promise;
};

export default function ThreeDModel({
    glbUrl,
    cameraX = 0,
    cameraY = 0,
    cameraZ = 10,
    modelX = 0,
    modelY = 0,
    modelZ = 0,
    modelScale = 2,
    rotationSpeed = 0.01,
    rotationDirection = 1,
    ambientLightIntensity = 1,
    directionalLightIntensity = 1,
}) {
    const mountRef = useRef(null);
    const objectRef = useRef(null);
    const animationRef = useRef(null);
    const rendererRef = useRef(null);
    const sceneRef = useRef(null);
    const cameraRef = useRef(null);
    const contextIdRef = useRef(null);
    const userInteracting = useRef(false);
    const lastInteractionTime = useRef(Date.now());
    const [isInViewport, setIsInViewport] = useState(true);
    const isMounted = useRef(true);
    
    // Detect device
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isMobile = /Mobi|Android/i.test(navigator.userAgent) || isIOS;
    
    // Context management functions
    const registerContext = () => {
        const id = Date.now().toString();
        activeContexts.add(id);
        contextIdRef.current = id;
        return id;
    };
    
    const unregisterContext = () => {
        if (contextIdRef.current) {
            activeContexts.delete(contextIdRef.current);
            contextIdRef.current = null;
        }
    };
    
    const canCreateContext = () => {
        return activeContexts.size < MAX_WEBGL_CONTEXTS;
    };

    // Resource cleanup
    const cleanup = () => {
        isMounted.current = false;
        
        if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
            animationRef.current = null;
        }
        
        if (sceneRef.current && objectRef.current) {
            sceneRef.current.remove(objectRef.current);
            objectRef.current.traverse((node) => {
                if (node.isMesh) {
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) {
                        if (Array.isArray(node.material)) {
                            node.material.forEach(mat => {
                                if (mat.map) mat.map.dispose();
                                mat.dispose();
                            });
                        } else {
                            if (node.material.map) node.material.map.dispose();
                            node.material.dispose();
                        }
                    }
                }
            });
            objectRef.current = null;
        }
        
        if (rendererRef.current) {
            rendererRef.current.dispose();
            rendererRef.current.forceContextLoss();
            rendererRef.current = null;
        }
        
        unregisterContext();
        sceneRef.current = null;
        cameraRef.current = null;
    };

    // Set up intersection observer
    useEffect(() => {
        const observer = new IntersectionObserver(
            (entries) => {
                setIsInViewport(entries[0].isIntersecting);
            },
            { threshold: 0.1 }
        );

        if (mountRef.current) observer.observe(mountRef.current);
        return () => {
            if (mountRef.current) observer.unobserve(mountRef.current);
        };
    }, []);

    // Main initialization
    useEffect(() => {
        if (!mountRef.current || !glbUrl) return;
        isMounted.current = true;
        
        if (!canCreateContext()) return;
        registerContext();

        // Clear container
        while (mountRef.current.firstChild) {
            mountRef.current.removeChild(mountRef.current.firstChild);
        }

        const loadModules = async () => {
            try {
                await Promise.all([
                    loadScript(ThreeJSURL),
                    loadScript(GLTFLoaderURL),
                    loadScript(OrbitControlsURL),
                ]);

                if (!isMounted.current) return;

                const THREE = window.THREE;
                const OrbitControls = window.THREE.OrbitControls || window.OrbitControls;
                const GLTFLoader = window.THREE.GLTFLoader || window.GLTFLoader;
                
                if (!THREE || !OrbitControls || !GLTFLoader) return;
                
                if (!THREE.OrbitControls) THREE.OrbitControls = OrbitControls;
                if (!THREE.GLTFLoader) THREE.GLTFLoader = GLTFLoader;

                // Create scene
                const scene = new THREE.Scene();
                scene.background = null;
                sceneRef.current = scene;

                // Setup camera
                const camera = new THREE.PerspectiveCamera(
                    50, 
                    mountRef.current.clientWidth / mountRef.current.clientHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 0, 5);
                cameraRef.current = camera;

                // Create renderer
                const renderer = new THREE.WebGLRenderer({ 
                    alpha: true, 
                    antialias: !isMobile,
                    precision: isMobile ? "mediump" : "highp"
                });
                renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                renderer.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
                
                // CRITICAL: This transparent div trick allows touches to pass through for vertical scrolling
                const container = document.createElement('div');
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.position = 'relative';
                container.style.touchAction = 'pan-y';
                
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.pointerEvents = 'none'; // Start with no pointer events
                
                container.appendChild(renderer.domElement);
                mountRef.current.appendChild(container);
                rendererRef.current = renderer;

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, ambientLightIntensity);
                const dirLight = new THREE.DirectionalLight(0xffffff, directionalLightIntensity);
                dirLight.position.set(5, 10, 5);
                const fillLight = new THREE.DirectionalLight(0xffffff, directionalLightIntensity * 0.3);
                fillLight.position.set(-5, -5, -5);
                scene.add(ambientLight, dirLight, fillLight);

                // Variables for touch handling
                let touchStartX = 0;
                let touchStartY = 0;
                let isHorizontalMove = null;
                let dragVelocity = 0;
                
                // Handle touch events
                const handleTouchStart = (e) => {
                    if (e.touches.length !== 1) return;
                    
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    isHorizontalMove = null;
                    userInteracting.current = false;
                };
                
                const handleTouchMove = (e) => {
                    if (e.touches.length !== 1) return;
                    
                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const deltaX = Math.abs(currentX - touchStartX);
                    const deltaY = Math.abs(currentY - touchStartY);
                    
                    // Determine direction if not already set
                    if (isHorizontalMove === null && (deltaX > 8 || deltaY > 8)) {
                        isHorizontalMove = deltaX > deltaY;
                        
                        if (isHorizontalMove) {
                            // Horizontal - enable rotation
                            renderer.domElement.style.pointerEvents = 'auto';
                            
                            if (e.cancelable) {
                                e.preventDefault();
                            }
                            
                            userInteracting.current = true;
                        } else {
                            // Vertical - disable pointer events to allow page scrolling
                            renderer.domElement.style.pointerEvents = 'none';
                            userInteracting.current = false;
                        }
                    }
                    
                    // Handle horizontal rotation
                    if (isHorizontalMove === true) {
                        userInteracting.current = true;
                        lastInteractionTime.current = Date.now();
                        
                        if (e.cancelable) {
                            e.preventDefault();
                        }
                        
                        // Rotate the model
                        if (objectRef.current) {
                            const rotateAmount = (currentX - touchStartX) * 0.01;
                            objectRef.current.rotation.y += rotateAmount;
                            dragVelocity = rotateAmount;
                            touchStartX = currentX;
                        }
                    }
                };
                
                const handleTouchEnd = () => {
                    // Reset pointer events to none to allow scrolling by default
                    renderer.domElement.style.pointerEvents = 'none';
                    
                    userInteracting.current = false;
                    lastInteractionTime.current = Date.now();
                    
                    // Add very slight momentum (much less than before)
                    if (isHorizontalMove === true) {
                        // Apply a small amount of momentum that quickly fades
                        dragVelocity = dragVelocity * 0.5; // Reduce velocity significantly
                    }
                };
                
                // Add touch event listeners to container
                container.addEventListener("touchstart", handleTouchStart, { passive: true });
                container.addEventListener("touchmove", handleTouchMove, { passive: false });
                container.addEventListener("touchend", handleTouchEnd, { passive: true });
                
                // Enable pointer events temporarily when touching container
                container.addEventListener("pointerdown", () => {
                    renderer.domElement.style.pointerEvents = 'auto';
                }, { passive: true });

                // Load model
                const loader = new THREE.GLTFLoader();
                loader.load(
                    glbUrl,
                    (gltf) => {
                        if (!isMounted.current) return;
                        
                        const model = gltf.scene;
                        
                        // Simple mobile optimizations without changing appearance
                        if (isMobile) {
                            model.traverse((node) => {
                                if (node.isMesh) {
                                    node.castShadow = false;
                                    node.receiveShadow = false;
                                    if (node.material) {
                                        if (Array.isArray(node.material)) {
                                            node.material.forEach(mat => {
                                                mat.precision = "mediump";
                                            });
                                        } else {
                                            node.material.precision = "mediump";
                                        }
                                    }
                                }
                            });
                        }
                        
                        model.scale.setScalar(modelScale);
                        model.position.set(modelX, modelY, modelZ);
                        scene.add(model);
                        objectRef.current = model;
                        
                        camera.lookAt(new THREE.Vector3(0, 0, 0));
                    },
                    undefined,
                    (err) => console.error("Error loading model:", err)
                );

                // Animation loop
                let lastTime = 0;
                const animate = (time) => {
                    if (!isMounted.current) return;
                    
                    animationRef.current = requestAnimationFrame(animate);
                    
                    const deltaTime = Math.min(0.05, (time - lastTime) / 1000);
                    lastTime = time;
                    
                    if (isInViewport && objectRef.current) {
                        if (!userInteracting.current) {
                            // Apply very brief momentum then quickly return to auto-rotation
                            if (Math.abs(dragVelocity) > 0.0001) {
                                objectRef.current.rotation.y += dragVelocity;
                                dragVelocity *= 0.9; // Decay quickly
                            } else {
                                // Auto-rotation with quick return after interaction
                                const elapsed = (Date.now() - lastInteractionTime.current) / 1000;
                                const targetSpeed = rotationSpeed * rotationDirection;
                                
                                // Start transitioning back to auto-rotation quickly
                                if (elapsed > 0.2) {
                                    // Fast transition back to auto-rotation 
                                    objectRef.current.rotation.y += targetSpeed;
                                }
                            }
                        }
                        
                        renderer.render(scene, camera);
                    }
                };
                
                animate(0);

                // Handle resize
                const handleResize = () => {
                    if (!mountRef.current || !camera || !renderer) return;
                    
                    camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                };
                
                window.addEventListener('resize', handleResize);

                // Cleanup
                return () => {
                    container.removeEventListener("touchstart", handleTouchStart);
                    container.removeEventListener("touchmove", handleTouchMove);
                    container.removeEventListener("touchend", handleTouchEnd);
                    container.removeEventListener("pointerdown", () => {
                        renderer.domElement.style.pointerEvents = 'auto';
                    });
                    
                    window.removeEventListener('resize', handleResize);
                    
                    cleanup();
                };
            } catch (e) {
                console.error("Scene initialization failed:", e);
                cleanup();
            }
        };

        loadModules();

        return () => cleanup();
    }, [glbUrl, modelX, modelY, modelZ, modelScale, rotationSpeed, rotationDirection, ambientLightIntensity, directionalLightIntensity]);

    return (
        <div 
            ref={mountRef} 
            style={{ 
                width: "100%", 
                height: "100%", 
                overflow: "visible",
                touchAction: "pan-y" 
            }} 
        />
    );
}

addPropertyControls(ThreeDModel, {
    glbUrl: { type: ControlType.String, title: "GLB URL" },
    cameraX: { type: ControlType.Number, title: "Camera X", defaultValue: 0 },
    cameraY: { type: ControlType.Number, title: "Camera Y", defaultValue: 0 },
    cameraZ: { type: ControlType.Number, title: "Camera Z", defaultValue: 10 },
    modelX: { type: ControlType.Number, title: "Model X", defaultValue: 0 },
    modelY: { type: ControlType.Number, title: "Model Y", defaultValue: 0 },
    modelZ: { type: ControlType.Number, title: "Model Z", defaultValue: 0 },
    modelScale: { type: ControlType.Number, title: "Model Scale", defaultValue: 2 },
    rotationSpeed: { type: ControlType.Number, title: "Rotation Speed" },
    rotationDirection: {
        type: ControlType.Enum,
        title: "Rotation Direction",
        options: [1, -1, 0],
        optionTitles: ["CCW", "CW", "None"],
    },
    ambientLightIntensity: {
        type: ControlType.Number,
        title: "Ambient Light",
        defaultValue: 1,
        min: 0,
        max: 3,
        step: 0.1,
    },
    directionalLightIntensity: {
        type: ControlType.Number,
        title: "Directional Light",
        defaultValue: 1,
        min: 0,
        max: 3,
        step: 0.1,
    },
});
