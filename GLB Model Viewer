import React, { useEffect, useRef } from "react";
import { addPropertyControls, ControlType } from "framer";

const ThreeJSURL = "https://unpkg.com/three@0.136.0/build/three.min.js";
const GLTFLoaderURL = "https://unpkg.com/three@0.136.0/examples/js/loaders/GLTFLoader.js";
const OrbitControlsURL = "https://unpkg.com/three@0.136.0/examples/js/controls/OrbitControls.js";

const scriptCache = new Map();
const loadScript = (url) => {
    if (scriptCache.has(url)) return scriptCache.get(url);
    const promise = new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = url;
        script.async = true;
        script.onload = () => resolve(true);
        script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
        document.head.appendChild(script);
    });
    scriptCache.set(url, promise);
    return promise;
};

export default function ThreeDModel({
    glbUrl,
    cameraX = 0,
    cameraY = 0,
    cameraZ = 10,
    modelX = 0,
    modelY = 0,
    modelZ = 0,
    modelScale = 2,
    rotationSpeed = 0.01,
    rotationDirection = 1,
    ambientLightIntensity = 1,
    directionalLightIntensity = 1,
}) {
    const mountRef = useRef(null);
    const objectRef = useRef(null);
    const animationRef = useRef(null);
    const controlsRef = useRef(null);
    const userInteracting = useRef(false);
    const lastInteractionTime = useRef(Date.now());
    const rendererRef = useRef(null);

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    useEffect(() => {
        if (!mountRef.current || !glbUrl) return;

        let disposed = false;

        const loadModules = async () => {
            try {
                await Promise.all([
                    loadScript(ThreeJSURL),
                    loadScript(GLTFLoaderURL),
                    loadScript(OrbitControlsURL),
                ]);

                const THREE = window.THREE;
                const OrbitControls = window.THREE.OrbitControls || window.OrbitControls;
                const GLTFLoader = window.THREE.GLTFLoader || window.GLTFLoader;
                if (!THREE || !OrbitControls || !GLTFLoader) return;
                if (!THREE.OrbitControls) THREE.OrbitControls = OrbitControls;
                if (!THREE.GLTFLoader) THREE.GLTFLoader = GLTFLoader;

                const scene = new THREE.Scene();
                scene.background = null;

                const camera = new THREE.PerspectiveCamera(50, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
                camera.position.set(cameraX, cameraY, cameraZ);

                const existing = mountRef.current.querySelector("canvas");
                if (existing) mountRef.current.removeChild(existing);

                const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.domElement.style.touchAction = "pan-y";
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.enableZoom = false;
                controls.enablePan = false;
                controls.minPolarAngle = Math.PI / 2;
                controls.maxPolarAngle = Math.PI / 2;
                controlsRef.current = controls;

                let startX = 0;
                let startY = 0;

                renderer.domElement.addEventListener("touchstart", (e) => {
                    if (e.touches.length === 1) {
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                        userInteracting.current = true;
                        lastInteractionTime.current = Date.now();
                    }
                });

                renderer.domElement.addEventListener("touchmove", (e) => {
                    if (e.touches.length === 1) {
                        const dx = Math.abs(e.touches[0].clientX - startX);
                        const dy = Math.abs(e.touches[0].clientY - startY);

                        if (dy > dx) {
                            controls.enabled = false;
                        } else {
                            if (e.cancelable) e.preventDefault();
                            controls.enabled = true;
                        }
                    }
                }, { passive: false });

                renderer.domElement.addEventListener("touchend", () => {
                    userInteracting.current = false;
                    lastInteractionTime.current = Date.now();
                    controls.enabled = true;
                });

                const ambientLight = new THREE.AmbientLight(0xffffff, ambientLightIntensity);
                const dirLight = new THREE.DirectionalLight(0xffffff, directionalLightIntensity);
                dirLight.position.set(5, 10, 5);

                const fillLight = new THREE.DirectionalLight(0xffffff, directionalLightIntensity * 0.3);
                fillLight.position.set(-5, -5, -5);

                scene.add(ambientLight, dirLight, fillLight);

                const loader = new THREE.GLTFLoader();
                loader.load(
                    glbUrl,
                    (gltf) => {
                        if (disposed) return;
                        const model = gltf.scene;
                        model.scale.setScalar(modelScale);
                        model.position.set(modelX, modelY, modelZ);
                        scene.add(model);
                        objectRef.current = model;

                        controls.target.copy(new THREE.Vector3(0, 0, 0));
                        camera.position.set(0, 0, 5);
                        camera.lookAt(controls.target);
                        controls.update();
                    },
                    undefined,
                    (err) => console.error("Error loading model", err)
                );

                let frameCount = 0;
                const animate = () => {
                    if (disposed) return;
                    animationRef.current = requestAnimationFrame(animate);

                    if (objectRef.current && rotationDirection !== 0) {
                        const elapsed = (Date.now() - lastInteractionTime.current) / 1000;
                        const easeFactor = Math.min(elapsed / 0.5, 1);
                        if (!userInteracting.current) {
                            objectRef.current.rotation.y += rotationSpeed * easeFactor * rotationDirection;
                        }
                    }

                    if (++frameCount % (isMobile ? 4 : 2) === 0) {
                        controls.update();
                        renderer.render(scene, camera);
                    }
                };
                animate();
            } catch (e) {
                console.error("Scene init failed:", e);
            }
        };

        loadModules();

        return () => {
            disposed = true;
            cancelAnimationFrame(animationRef.current);
            if (rendererRef.current) {
                rendererRef.current.dispose();
                rendererRef.current.forceContextLoss();
                if (rendererRef.current.domElement?.parentNode) {
                    rendererRef.current.domElement.parentNode.removeChild(rendererRef.current.domElement);
                }
                rendererRef.current = null;
            }
        };
    }, [glbUrl, cameraX, cameraY, cameraZ, modelX, modelY, modelZ, modelScale, rotationSpeed, rotationDirection, ambientLightIntensity, directionalLightIntensity]);

    return <div ref={mountRef} style={{ width: "100%", height: "100%", overflow: "visible", touchAction: "pan-y" }} />;
}

addPropertyControls(ThreeDModel, {
    glbUrl: { type: ControlType.String, title: "GLB URL" },
    cameraX: { type: ControlType.Number, title: "Camera X", defaultValue: 0 },
    cameraY: { type: ControlType.Number, title: "Camera Y", defaultValue: 0 },
    cameraZ: { type: ControlType.Number, title: "Camera Z", defaultValue: 10 },
    modelX: { type: ControlType.Number, title: "Model X", defaultValue: 0 },
    modelY: { type: ControlType.Number, title: "Model Y", defaultValue: 0 },
    modelZ: { type: ControlType.Number, title: "Model Z", defaultValue: 0 },
    modelScale: { type: ControlType.Number, title: "Model Scale", defaultValue: 2 },
    rotationSpeed: { type: ControlType.Number, title: "Rotation Speed" },
    rotationDirection: {
        type: ControlType.Enum,
        title: "Rotation Direction",
        options: [1, -1, 0],
        optionTitles: ["CCW", "CW", "None"],
    },
    ambientLightIntensity: {
        type: ControlType.Number,
        title: "Ambient Light",
        defaultValue: 1,
        min: 0,
        max: 3,
        step: 0.1,
    },
    directionalLightIntensity: {
        type: ControlType.Number,
        title: "Directional Light",
        defaultValue: 1,
        min: 0,
        max: 3,
        step: 0.1,
    },
});

